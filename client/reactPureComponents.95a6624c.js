import{l as e,m as t,o as n,n as a,t as r,p as s,q as o,e as i,s as m,C as p,c as g,d as c,b as $,f as u,h as f,i as d,S as l,j as h,k as w}from"./client.f707559f.js";import"./Icon.b3087117.js";import"./Button.46d81a0e.js";import"./Image.a80d16de.js";import"./stores.ec09ff7a.js";import{H as b,P as v,a as R,N as y,C}from"./index.b8f1b6e6.js";function L(i){let m;const p=new b({props:{data:"React Pure Components",id:"reactPureComponents",isBig:"true"}}),g=new v({props:{data:"<p>Before understanding <em>Pure Components</em> first let us see what is a pure function in Javascript.</p>"}}),c=new b({props:{data:"Pure Functions",id:"pureFunctions"}}),$=new v({props:{data:"<ul><li><strong>Pure Functions</strong> always returns same result for same inputs passed.</li><li><strong>Pure Functions</strong> must not change the inputs passed.</li><li><strong>Pure Functions</strong> must not use on external variables.</li><li><strong>Pure Functions </strong>must not make any subscriptions or network calls.</li><li><strong>Pure Functions </strong>must return something based on inputs given.</li></ul><p><br></p>"}}),u=new R({props:{language:"javascript",uid:"b4f72d01-3848-11ea-9473-4d0bf4750a30",data:"function impureFunction(value) {\n  return ++value;\n}",pic:"",ratio:"4",highlight:""}}),f=new v({props:{data:"<p>The above function is impure because it is changing given input</p>"}}),d=new R({props:{language:"javascript",uid:"d80bd8f1-3847-11ea-9473-4d0bf4750a30",data:"let factor = 2;\n\nfunction impureFunction(value) {\n  return value * factor\n}",pic:"",ratio:"4",highlight:""}}),l=new v({props:{data:"<p>The above function is impure because it depends on variables outside of it.</p>"}}),h=new R({props:{language:"javascript",uid:"eb2199b1-3848-11ea-9473-4d0bf4750a30",data:"function impureFunction(value) {\n  value * 2\n}",pic:"",ratio:"4",highlight:""}}),w=new v({props:{data:"<p>The above function is impure because it depends return anything.</p><p><br></p>"}}),C=new R({props:{language:"javascript",uid:"02c674f1-3849-11ea-9473-4d0bf4750a30",data:"function pureFunction(value) {\n  return value * 2\n}",pic:"",ratio:"4",highlight:""}}),L=new v({props:{data:"<p>The above function is pure because it depends only on the givin input, and its output is always same for given input.</p><p><br></p><p>Now you have understood the concept of pure function. Now let's see how React applies this concept for components.</p>"}}),P=new b({props:{data:"Pure Component in React",id:"pureComponentInReact"}}),x=new v({props:{data:'<p>Just like pure function a Pure component in React renders same output for same state and props.</p><p>React provides <strong>React.PureComponent</strong> class, A class that extends <strong>React.PureComponent </strong>is treated as PureComponent.</p><p><br></p><p>A PureComponent is same as normal class based component, except PureComponent takes care of <a href="/reactJs/course/reactComponents/reactComponentLifecycle#shouldComponentUpdate" target="_blank">shouldComponentUpdate</a>. It does a shallow comparision between existing <strong>this.props</strong> and <strong>this.state</strong> with the <strong>nextProps</strong> and <strong>nextState</strong>. If any references of props or stats are changed then shouldComponentUpdate return true else it returns false.</p>'}}),I=new b({props:{data:"Pure components example 1",id:"pureComponentsExample1"}}),j=new R({props:{language:"javascript",uid:"2b2c41a1-39a1-11ea-81ac-7bd136148f47",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class App extends React.Component {\n    state = {\n        name: \"Manoj\",\n        age: 26\n    };\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState({\n                age: 26\n            })\n        }, 1000)\n    }\n\n    render() {\n        console.log(\"Rendering\");\n        return (\n            <div>\n                Hello {this.state.name}\n            </div>\n        );\n    }\n}\n\nReactDOM.render(<App/>, document.getElementById('root'));\n",pic:"",ratio:"4",highlight:"5, 12-16"}}),M=new v({props:{data:"<p>Observe in the above example we are calling setState without any change in data but for every minute component is re-rendered with the same UI which is not good for performance.</p><p><br></p>"}}),k=new R({props:{language:"javascript",uid:"3627c551-39a3-11ea-81ac-7bd136148f47",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class App extends React.PureComponent {\n    state = {\n        name: \"Manoj\",\n        age: 26\n    };\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState({\n                age: 26\n            })\n        }, 1000)\n    }\n\n    render() {\n        console.log(\"Rendering\");\n        return (\n            <div>\n                Hello {this.state.name}\n            </div>\n        );\n    }\n}\n\nReactDOM.render(<App/>, document.getElementById('root'));\n",pic:"",ratio:"4",highlight:"5"}}),F=new v({props:{data:"<p>Here we have extended <strong>React.PureComponent</strong> with the same code. Now if you observe component is not re-rendered for every minute because though we are calling <strong>setState() </strong>PureComonent makes shallow comparision between state and props, if there are any changes then only rendering logic will be executed.</p><p><br></p><p>Let us see another example</p>"}}),D=new b({props:{data:"Pure components example 2",id:"pureComponentsExample2"}}),O=new R({props:{language:"javascript",uid:"c12cf231-39ba-11ea-81ac-7bd136148f47",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.Component {\n    state = {\n        list: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                const newList = state.list;\n                newList.push(\"item\" + this.count++);\n                return ({\n                        list: newList\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {\n                    this.state.list.map(item => <ListItem key={item} name={item}/>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nclass ListItem extends React.Component {\n    render() {\n        console.log(\"Rendering: \" + this.props.name);\n        return (\n            <p>{this.props.name}</p>\n        )\n    }\n}\n\nReactDOM.render(<List/>, document.getElementById('root'));\n",pic:"",ratio:"4",highlight:"12-21, 35, 37"}}),A=new v({props:{data:"<p>Here for every minute we are adding a new item to the list. If we run this code output looks fine, but if we open the console we can see the <strong>Rendering log is printed for all the items in the list for every push in the list</strong>. That means all the items of the list are re-rendered. But this is not what we are expecting, we need to render only the newly added item not the entire list.</p><p><br></p><p>Here PureComponent can optimise this behaviour.</p><p>In the line number 35 let us change <em>ListItem</em> to extend <strong>React.PureComponent</strong>.</p>"}}),S=new R({props:{language:"javascript",uid:"c73a8f01-39bc-11ea-81ac-7bd136148f47",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.Component {\n    state = {\n        list: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                const newList = state.list;\n                newList.push(\"item\" + this.count++);\n                return ({\n                        list: newList\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {\n                    this.state.list.map(item => <ListItem key={item} name={item}/>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nclass ListItem extends React.PureComponent {\n    render() {\n        console.log(\"Rendering: \" + this.props.name);\n        return (\n            <p>{this.props.name}</p>\n        )\n    }\n}\n\nReactDOM.render(<List/>, document.getElementById('root'));\n",pic:"",ratio:"4",highlight:"12-21, 35, 37"}}),B=new v({props:{data:"<p>Now if we see the console we can notice that <strong>Rendering log </strong>for only newly added item is printed. That means only newly added item is created and existing List items are untouched.</p><p><br></p><p>For every push in the list <em>List</em> Component is re-rendered so <strong>shouldComponentUpdate</strong> for all the <em>ListItem</em> Components are called, as <em>ListItem</em> is a pure component and <strong>this.props.name </strong>is not changed existing List items are untouched.</p><p><br></p><p>So we can smartly use Pure components for better performance.</p>"}}),E=new y({props:{data:"<ul><li><strong>React.PureComponent </strong>can boost performance.</li><li>Use <strong>this.forceUpdate() </strong>to re-render PureComponent ignoring changes in props or state.</li><li>If PureComponent skips a re-render all it's children components are also not re-rendered.</li></ul>"}}),T=new b({props:{data:"Pure Components with reference data types",id:"pureComponentsWithReferenceDataTypes"}}),U=new v({props:{data:"<p><strong>React.PureComponent</strong> only shallow compares the objects. So changes in the primitive datatypes can be easily detected. But in case of reference datatypes(object, array) React.PureComponent can only detect change if reference is changed.</p>"}}),H=new R({props:{language:"javascript",uid:"dcddaa01-39c0-11ea-81ac-7bd136148f47",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.PureComponent {\n    state = {\n        itemsList: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                const newList = state.itemsList;\n                newList.push(\"item\" + this.count++);\n                return ({\n                        itemsList: newList\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {\n                    this.state.itemsList.map(item => <p key={item}>{item}</p>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nReactDOM.render(<List/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:"5, 13-20"}}),N=new v({props:{data:"<p>This is simple PureComponent where the <strong>list</strong> is updated for every minute.</p><p>But the code doesn't work. Because if you observe the <strong>setState() </strong>from lines 13-20 we are mutating the original <em>itemsList</em>. So as reference is same and shallow comparison for itemsList gives false so <em>List</em> component skips re-render.</p>"}}),J=new R({props:{language:"javascript",uid:"c7582f81-39c4-11ea-81ac-7bd136148f47",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.PureComponent {\n    state = {\n        itemsList: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                return ({\n                        itemsList: [...this.state.itemsList, \"item\" + this.count++]\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        console.log(\"Rendering\");\n        return (\n            <React.Fragment>\n                {\n                    this.state.itemsList.map(item => <p key={item}>{item}</p>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nReactDOM.render(<List/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:"13-18"}}),_=new v({props:{data:'<p>Observe lines from 13 to 18 we have used <span style="background-color: rgb(230, 0, 0);">es6 way of shallow cloning array</span>. As reference is changed this code works properly.</p><p><br></p><p>This is good sollution for small objects or arrays, but if we use deeply nested objects or arrays we should use deep cloning but this can cause negative performance impact.</p>'}}),q=new y({props:{data:'<p>PureComponents are ment for performance optimisation, but use PureComponents for simple props and state, or use <strong>this.forceUpdate() </strong> when you know deep structure has changed. Or use <a href="https://immutable-js.github.io/immutable-js/" target="_blank">immutable.js objects</a>.</p>'}});return{c(){e(p.$$.fragment),e(g.$$.fragment),e(c.$$.fragment),e($.$$.fragment),e(u.$$.fragment),e(f.$$.fragment),e(d.$$.fragment),e(l.$$.fragment),e(h.$$.fragment),e(w.$$.fragment),e(C.$$.fragment),e(L.$$.fragment),e(P.$$.fragment),e(x.$$.fragment),e(I.$$.fragment),e(j.$$.fragment),e(M.$$.fragment),e(k.$$.fragment),e(F.$$.fragment),e(D.$$.fragment),e(O.$$.fragment),e(A.$$.fragment),e(S.$$.fragment),e(B.$$.fragment),e(E.$$.fragment),e(T.$$.fragment),e(U.$$.fragment),e(H.$$.fragment),e(N.$$.fragment),e(J.$$.fragment),e(_.$$.fragment),e(q.$$.fragment)},l(e){t(p.$$.fragment,e),t(g.$$.fragment,e),t(c.$$.fragment,e),t($.$$.fragment,e),t(u.$$.fragment,e),t(f.$$.fragment,e),t(d.$$.fragment,e),t(l.$$.fragment,e),t(h.$$.fragment,e),t(w.$$.fragment,e),t(C.$$.fragment,e),t(L.$$.fragment,e),t(P.$$.fragment,e),t(x.$$.fragment,e),t(I.$$.fragment,e),t(j.$$.fragment,e),t(M.$$.fragment,e),t(k.$$.fragment,e),t(F.$$.fragment,e),t(D.$$.fragment,e),t(O.$$.fragment,e),t(A.$$.fragment,e),t(S.$$.fragment,e),t(B.$$.fragment,e),t(E.$$.fragment,e),t(T.$$.fragment,e),t(U.$$.fragment,e),t(H.$$.fragment,e),t(N.$$.fragment,e),t(J.$$.fragment,e),t(_.$$.fragment,e),t(q.$$.fragment,e)},m(e,t){n(p,e,t),n(g,e,t),n(c,e,t),n($,e,t),n(u,e,t),n(f,e,t),n(d,e,t),n(l,e,t),n(h,e,t),n(w,e,t),n(C,e,t),n(L,e,t),n(P,e,t),n(x,e,t),n(I,e,t),n(j,e,t),n(M,e,t),n(k,e,t),n(F,e,t),n(D,e,t),n(O,e,t),n(A,e,t),n(S,e,t),n(B,e,t),n(E,e,t),n(T,e,t),n(U,e,t),n(H,e,t),n(N,e,t),n(J,e,t),n(_,e,t),n(q,e,t),m=!0},p:a,i(e){m||(r(p.$$.fragment,e),r(g.$$.fragment,e),r(c.$$.fragment,e),r($.$$.fragment,e),r(u.$$.fragment,e),r(f.$$.fragment,e),r(d.$$.fragment,e),r(l.$$.fragment,e),r(h.$$.fragment,e),r(w.$$.fragment,e),r(C.$$.fragment,e),r(L.$$.fragment,e),r(P.$$.fragment,e),r(x.$$.fragment,e),r(I.$$.fragment,e),r(j.$$.fragment,e),r(M.$$.fragment,e),r(k.$$.fragment,e),r(F.$$.fragment,e),r(D.$$.fragment,e),r(O.$$.fragment,e),r(A.$$.fragment,e),r(S.$$.fragment,e),r(B.$$.fragment,e),r(E.$$.fragment,e),r(T.$$.fragment,e),r(U.$$.fragment,e),r(H.$$.fragment,e),r(N.$$.fragment,e),r(J.$$.fragment,e),r(_.$$.fragment,e),r(q.$$.fragment,e),m=!0)},o(e){s(p.$$.fragment,e),s(g.$$.fragment,e),s(c.$$.fragment,e),s($.$$.fragment,e),s(u.$$.fragment,e),s(f.$$.fragment,e),s(d.$$.fragment,e),s(l.$$.fragment,e),s(h.$$.fragment,e),s(w.$$.fragment,e),s(C.$$.fragment,e),s(L.$$.fragment,e),s(P.$$.fragment,e),s(x.$$.fragment,e),s(I.$$.fragment,e),s(j.$$.fragment,e),s(M.$$.fragment,e),s(k.$$.fragment,e),s(F.$$.fragment,e),s(D.$$.fragment,e),s(O.$$.fragment,e),s(A.$$.fragment,e),s(S.$$.fragment,e),s(B.$$.fragment,e),s(E.$$.fragment,e),s(T.$$.fragment,e),s(U.$$.fragment,e),s(H.$$.fragment,e),s(N.$$.fragment,e),s(J.$$.fragment,e),s(_.$$.fragment,e),s(q.$$.fragment,e),m=!1},d(e){o(p,e),o(g,e),o(c,e),o($,e),o(u,e),o(f,e),o(d,e),o(l,e),o(h,e),o(w,e),o(C,e),o(L,e),o(P,e),o(x,e),o(I,e),o(j,e),o(M,e),o(k,e),o(F,e),o(D,e),o(O,e),o(A,e),o(S,e),o(B,e),o(E,e),o(T,e),o(U,e),o(H,e),o(N,e),o(J,e),o(_,e),o(q,e)}}}function P(a){let l,h,w;const b=new C({props:{$$slots:{default:[L]},$$scope:{ctx:a}}});return{c(){l=i("meta"),h=m(),e(b.$$.fragment),this.h()},l(e){const n=p('[data-svelte="svelte-1s6lk8b"]',document.head);l=g(n,"META",{name:!0,content:!0}),n.forEach(c),h=$(e),t(b.$$.fragment,e),this.h()},h(){document.title="React Pure Components",u(l,"name","description"),u(l,"content","React Pure Components")},m(e,t){f(document.head,l),d(e,h,t),n(b,e,t),w=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),b.$set(n)},i(e){w||(r(b.$$.fragment,e),w=!0)},o(e){s(b.$$.fragment,e),w=!1},d(e){c(l),e&&c(h),o(b,e)}}}export default class extends l{constructor(e){super(),h(this,e,null,P,w,{})}}
