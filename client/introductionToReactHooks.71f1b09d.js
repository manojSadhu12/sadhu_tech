import{l as e,m as t,o,n,t as s,p as a,q as r,e as c,s as p,C as i,c as l,d as m,b as d,f as h,h as u,i as f,S as g,j as $,k as b}from"./client.f707559f.js";import"./Icon.b3087117.js";import"./Button.46d81a0e.js";import"./Image.a80d16de.js";import"./stores.ec09ff7a.js";import{H as w,P as k,C as y}from"./index.b8f1b6e6.js";function H(c){let p;const i=new w({props:{data:"React Hooks",id:"reactHooks",isBig:"true"}}),l=new k({props:{data:"<p>Hooks were added in React 16.8. Hooks lets us handle state and other features in function components.</p><p>Hooks doesn't work in classes. But you can always mix classes and function components in a React app.</p><p><br></p><p><strong>React doesn't plan to remove class</strong>. You can use both class and functions.</p><p><br></p><p><strong>Hooks donâ€™t replace your knowledge of React concepts.</strong> Instead, Hooks provides a more direct API to the React concepts you already know: props, state, context, refs, and lifecycle. Hooks also offer a new powerful way to combine them.</p><p><br></p>"}}),m=new w({props:{data:"Why Hooks",id:"whyHooks"}}),d=new k({props:{data:'<h2>Problems with classes</h2><p>This is more related to Javascript than React.</p><p><br></p><ul><li>To work with classes you should have better understanding on how <em>this</em> works in Javascript, which is very different from how it works in most languages.</li><li>You have to remember to bind event handlers.</li><li>People can understand props, state, and top-down data flow perfectly well but still struggle with classes.</li><li>Class dont\' minify well and make hot reloading very unreliable.</li></ul><p><br></p><h2>Problems with Reusing stateful logic between components</h2><p>Before React hooks(i.e before react verion 16.8) there is no proper way to reuse statefull logic amoung comonents(like connecting to store or http requests). Render props and higher-order components that try to solve this. But these patterns require you to restructure components which kind of results in awkard looking code, you end up wrapping your components with other comonents to share the functionality. So its harder to maintain this code.</p><p><br></p><p>This problem is solved by hooks, We can write and test hooks independently and share them across components without changing component hierachy. This can be done with custom hooks.</p><p><br></p><h2>Solving Components become more complex</h2><p>When we create Components for complex problems like </p><p>Data fetching in <a href="/courses/reactJs/reactComponents/reactComponentLifecycle#componentDidMount" target="_blank">componentDidMount</a> and in some times in <a href="/courses/reactJs/reactComponents/reactComponentLifecycle#componentDidUpdate" target="_blank">componentDidUpdate</a> also.</p><p>Subscribe to events in <a href="/courses/reactJs/reactComponents/reactComponentLifecycle#componentDidMount" target="_blank">componentDidMount</a> and unsubscribe events in <a href="/courses/reactJs/reactComponents/reactComponentLifecycle#componentWillUnmount" target="_blank">componentWillUnmount</a>.</p><p><br></p><p>Here related code is not organized in one place it is seperated in seperate methods. And unrelated code data fetching and event subscriptions end up in <a href="/courses/reactJs/reactComponents/reactComponentLifecycle#componentDidMount" target="_blank">componentDidMount</a>.</p><p><br></p><p>Because of statefull logic we can\'t break the components into smaller ones.</p><p><br></p><p>So complex components are becoming more complicated.</p><p><br></p><p>Hooks lets you split this logic into smaller functions based on what pieces are related. This can be done with <a href="/courses/reactJs/reactHooks/useEffectHook" target="_blank">useEffect Hook</a>.</p>'}});return{c(){e(i.$$.fragment),e(l.$$.fragment),e(m.$$.fragment),e(d.$$.fragment)},l(e){t(i.$$.fragment,e),t(l.$$.fragment,e),t(m.$$.fragment,e),t(d.$$.fragment,e)},m(e,t){o(i,e,t),o(l,e,t),o(m,e,t),o(d,e,t),p=!0},p:n,i(e){p||(s(i.$$.fragment,e),s(l.$$.fragment,e),s(m.$$.fragment,e),s(d.$$.fragment,e),p=!0)},o(e){a(i.$$.fragment,e),a(l.$$.fragment,e),a(m.$$.fragment,e),a(d.$$.fragment,e),p=!1},d(e){r(i,e),r(l,e),r(m,e),r(d,e)}}}function v(n){let g,$,b;const w=new y({props:{$$slots:{default:[H]},$$scope:{ctx:n}}});return{c(){g=c("meta"),$=p(),e(w.$$.fragment),this.h()},l(e){const o=i('[data-svelte="svelte-ifgp83"]',document.head);g=l(o,"META",{name:!0,content:!0}),o.forEach(m),$=d(e),t(w.$$.fragment,e),this.h()},h(){document.title="React Hooks",h(g,"name","description"),h(g,"content","What are React Hook, Why should we use them and What are the rules of using React Hooks.")},m(e,t){u(document.head,g),f(e,$,t),o(w,e,t),b=!0},p(e,[t]){const o={};1&t&&(o.$$scope={dirty:t,ctx:e}),w.$set(o)},i(e){b||(s(w.$$.fragment,e),b=!0)},o(e){a(w.$$.fragment,e),b=!1},d(e){m(g),e&&m($),r(w,e)}}}export default class extends g{constructor(e){super(),$(this,e,null,v,b,{})}}
