import{l as e,m as t,o as n,n as a,t as o,p as s,q as r,e as c,s as m,C as i,c as u,d as p,b as d,f as l,h as f,i as g,S as h,j as $,k as y}from"./client.f707559f.js";import"./Icon.b3087117.js";import"./Button.46d81a0e.js";import"./Image.a80d16de.js";import"./stores.ec09ff7a.js";import{H as b,a as v,P as x,N as w,C as M}from"./index.b8f1b6e6.js";function j(c){let m;const i=new b({props:{data:"useMemo",id:"useMemo",isBig:"true"}}),u=new v({props:{language:"javascript",uid:"8c4ec4f1-717b-11ea-97c6-61ac10c437eb",data:"/**\n * @param first param is a factory function.\n * @param second param is the list of dependencies\n * @returns the memoized value, factory function will be recomputed only changes if one of the dependencies has changed.\n */\n\nconst memoizedValue = useMemo(\n    (//arguments are not allowed) => {\n        //compute expensive code and return a value\n    }, [\n        //dependencies list\n    ]);",pic:"",ratio:"4",highlight:""}}),p=new x({props:{data:"<p><br></p><p>We know that all the code inside the function component executes for every render. So all the functions inside the component will be reexecuted for every so it is an performance issue.</p><p><br></p><p>So we can use the useMemo hook to only reexecute the function if any of the dependencies in the second param (dependencies list) is changed, React makes a shallow comparision(i.e reference comparision) of dependencies to find out the changes.</p><p><br></p><p>Every value used in the factory function should be mentioned in the dependencies list.</p><p><br></p>"}}),d=new v({props:{language:"javascript",uid:"da20daf1-719a-11ea-97c6-61ac10c437eb",data:"import React, {useMemo, useState} from 'react';\nimport ReactDOM from 'react-dom';\nimport './App.css';\n\nconst Product = () => {\n    const [productName, setProductName] = useState(\"\");\n    const [amount, setAmount] = useState(1);\n    const calculatedAmount = useMemo(\n        () => {\n            console.log(\"Expensive Execution\");\n            for (let i = 0; i < 1000000000; i++) ;// Simulating  a delay\n            return amount * 2;\n        }, [amount]);\n\n    return (\n        <React.Fragment>\n            <input placeholder=\"Product Name\"\n                   value={productName} onChange={e => setProductName(e.target.value)}/>\n            \n            <input type='number' placeholder=\"Amount\"\n                   value={amount} onChange={e => setAmount(+e.target.value)}/>\n            \n            <p>{calculatedAmount}</p>\n        </React.Fragment>\n    );\n};\n\nexport default Product;\n\nReactDOM.render(<Product/>, document.getElementById('root'));",pic:"/images/da86ed50-f336-11e9-b4ff-ad48fafeab92___01e396e0-71a0-11ea-97c6-61ac10c437eb.png",ratio:"8",highlight:"8-13"}}),l=new x({props:{data:'<p>In the above example lines 8-13 show the usage of <em>useMemo</em> hook, <strong>amount </strong>is given as a dependency.</p><p><br></p><p>Line 11 is written to make some delay in execution to show some expensive code is executed.</p><p><br></p><p>When the page loads <strong>"Expensive Execution log" </strong>prints to the console and it evaluates <strong>calculatedAmount </strong>value. For any change in the <strong>productName </strong>state <em>useMemo</em> won\'t execute the factory method, you can see it because there wont be any log in the console. The factory method is only executed for changes in amount so you can see the log in the console.</p>'}}),f=new w({props:{data:'<ul><li>Use <em>useMemo</em> only for expensive calculations. Don\'t use <em>useMemo</em> in many places for every small calculations it may lead to negative performance.</li><li>Don\'t use <em>useMemo</em> when there are no dependancies, if there are no dependancies <em>useMemo</em> executes for every single render. In this case <a href="/courses/reactJs/reactHooks/useRefHook" target="_blank">useRef hook</a> is the best fit.</li></ul>'}});return{c(){e(i.$$.fragment),e(u.$$.fragment),e(p.$$.fragment),e(d.$$.fragment),e(l.$$.fragment),e(f.$$.fragment)},l(e){t(i.$$.fragment,e),t(u.$$.fragment,e),t(p.$$.fragment,e),t(d.$$.fragment,e),t(l.$$.fragment,e),t(f.$$.fragment,e)},m(e,t){n(i,e,t),n(u,e,t),n(p,e,t),n(d,e,t),n(l,e,t),n(f,e,t),m=!0},p:a,i(e){m||(o(i.$$.fragment,e),o(u.$$.fragment,e),o(p.$$.fragment,e),o(d.$$.fragment,e),o(l.$$.fragment,e),o(f.$$.fragment,e),m=!0)},o(e){s(i.$$.fragment,e),s(u.$$.fragment,e),s(p.$$.fragment,e),s(d.$$.fragment,e),s(l.$$.fragment,e),s(f.$$.fragment,e),m=!1},d(e){r(i,e),r(u,e),r(p,e),r(d,e),r(l,e),r(f,e)}}}function k(a){let h,$,y;const b=new M({props:{$$slots:{default:[j]},$$scope:{ctx:a}}});return{c(){h=c("meta"),$=m(),e(b.$$.fragment),this.h()},l(e){const n=i('[data-svelte="svelte-283jb9"]',document.head);h=u(n,"META",{name:!0,content:!0}),n.forEach(p),$=d(e),t(b.$$.fragment,e),this.h()},h(){document.title="react useMemo",l(h,"name","description"),l(h,"content","react useMemo")},m(e,t){f(document.head,h),g(e,$,t),n(b,e,t),y=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),b.$set(n)},i(e){y||(o(b.$$.fragment,e),y=!0)},o(e){s(b.$$.fragment,e),y=!1},d(e){p(h),e&&p($),r(b,e)}}}export default class extends h{constructor(e){super(),$(this,e,null,k,y,{})}}
