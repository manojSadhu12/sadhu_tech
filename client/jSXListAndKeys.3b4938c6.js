import{l as e,m as a,o as n,n as t,t as s,p as r,q as i,e as o,s as d,C as f,c as p,d as c,b as m,f as $,h as l,i as g,S as u,j as h,k as b}from"./client.9c259cf4.js";import"./Icon.680bd4d0.js";import"./Button.44f5306d.js";import"./Image.c8019b1e.js";import"./stores.2b7dbef2.js";import{H as y,P as k,a as v,C as w}from"./index.7beba4f9.js";function j(o){let d;const f=new y({props:{data:"JSX List and Keys",id:"jSXListAndKeys",isBig:"true"}}),p=new y({props:{data:"List in JSX",id:"listInJSX"}}),c=new k({props:{data:'<p>To output a list of JSX elements we have to convert regular Javascript Array into array of JSX elements. For this we use <span style="background-color: rgb(230, 0, 0);">Javascript map</span>.</p>'}}),m=new v({props:{language:"javascript",uid:"800bf481-2467-11ea-9535-7fba82c7bc40",data:'const friends = [\n    {name: "Friend 1", age: 25},\n    {name: "Friend 2", age: 24},\n    {name: "Friend 3", age: 26}\n];\n\nfunction App() {\n    return (\n        <ul>\n            {friends.map(friend => (\n                <li value>{friend.name} - {friend.age}</li>\n            ))}\n        </ul>\n    )\n}',pic:"/images/da86ed50-f336-11e9-b4ff-ad48fafeab92___95a85bf0-246f-11ea-8988-81bac9bb2a1f.jpg",ratio:"8",highlight:"10-12"}}),$=new k({props:{data:'<p>Observe lines 10 to 12. Here <span style="background-color: black;"> friends </span> is a normal Javascript array and <span style="background-color: rgb(230, 0, 0);">map</span> has converted it into JSX array. As this array is dynamic we have wrapped this in <span style="background-color: black;"> { </span> <span style="background-color: black;"> } </span>.</p><p>The above code work\'s but if you open console you will get a worning like <span style="background-color: rgb(255, 194, 102);"> Each child in a list should have a unique "key" prop </span>.</p>'}}),l=new y({props:{data:"JSX keys",id:"jSXKeys"}}),g=new k({props:{data:'<p><span style="background-color: black;"> key </span> is a special attribute that React provides which is not there in HTML.</p><p>Unique keys should be given to the elements inside array so React can identify which items have changed or added or removed.</p>'}}),u=new v({props:{language:"javascript",uid:"a15dad41-1ee0-11ea-9f91-6bb67c0552fe",data:'const friends = [\n    {id: "id1", name: "Friend 1", age: 25},\n    {id: "id2", name: "Friend 2", age: 24},\n    {id: "id3", name: "Friend 3", age: 26}\n];\n\nfunction App() {\n    return (\n        <ul>\n            {friends.map(friend => (\n                <li key={friend.id} value>{friend.name} - {friend.age}</li>\n            ))}\n        </ul>\n    )\n}',ratio:"4",highlight:""}}),h=new k({props:{data:'<p>This code work\'s without wornings.</p><ul><li>Unique string should be given as key for elements inside array.</li><li>React uses <span style="background-color: black;"> key </span> to identify DOM elements.</li><li>Never use index as key if order of elements may change, if the order of the list is changed, previous key will represent another element but React cannot identify it because if the key is same as before React assumes that the DOM element represents the same component as before and this leads to inconsistency in application state.</li></ul>'}});return{c(){e(f.$$.fragment),e(p.$$.fragment),e(c.$$.fragment),e(m.$$.fragment),e($.$$.fragment),e(l.$$.fragment),e(g.$$.fragment),e(u.$$.fragment),e(h.$$.fragment)},l(e){a(f.$$.fragment,e),a(p.$$.fragment,e),a(c.$$.fragment,e),a(m.$$.fragment,e),a($.$$.fragment,e),a(l.$$.fragment,e),a(g.$$.fragment,e),a(u.$$.fragment,e),a(h.$$.fragment,e)},m(e,a){n(f,e,a),n(p,e,a),n(c,e,a),n(m,e,a),n($,e,a),n(l,e,a),n(g,e,a),n(u,e,a),n(h,e,a),d=!0},p:t,i(e){d||(s(f.$$.fragment,e),s(p.$$.fragment,e),s(c.$$.fragment,e),s(m.$$.fragment,e),s($.$$.fragment,e),s(l.$$.fragment,e),s(g.$$.fragment,e),s(u.$$.fragment,e),s(h.$$.fragment,e),d=!0)},o(e){r(f.$$.fragment,e),r(p.$$.fragment,e),r(c.$$.fragment,e),r(m.$$.fragment,e),r($.$$.fragment,e),r(l.$$.fragment,e),r(g.$$.fragment,e),r(u.$$.fragment,e),r(h.$$.fragment,e),d=!1},d(e){i(f,e),i(p,e),i(c,e),i(m,e),i($,e),i(l,e),i(g,e),i(u,e),i(h,e)}}}function J(t){let u,h,b;const y=new w({props:{$$slots:{default:[j]},$$scope:{ctx:t}}});return{c(){u=o("meta"),h=d(),e(y.$$.fragment),this.h()},l(e){const n=f('[data-svelte="svelte-1jyj5b9"]',document.head);u=p(n,"META",{name:!0,content:!0}),n.forEach(c),h=m(e),a(y.$$.fragment,e),this.h()},h(){document.title="JSX List and Keys",$(u,"name","description"),$(u,"content","JSX List and Keys")},m(e,a){l(document.head,u),g(e,h,a),n(y,e,a),b=!0},p(e,[a]){const n={};1&a&&(n.$$scope={dirty:a,ctx:e}),y.$set(n)},i(e){b||(s(y.$$.fragment,e),b=!0)},o(e){r(y.$$.fragment,e),b=!1},d(e){c(u),e&&c(h),i(y,e)}}}export default class extends u{constructor(e){super(),h(this,e,null,J,b,{})}}
