import{l as e,m as t,o as n,n as s,t as a,p as r,q as o,e as m,s as i,C as p,c,d,b as l,f as g,h as $,i as f,S as h,j as u,k as w}from"./client.f707559f.js";import"./Icon.b3087117.js";import"./Button.46d81a0e.js";import"./Image.a80d16de.js";import"./stores.ec09ff7a.js";import{H as R,P as b,a as y,N as L,C as I}from"./index.b8f1b6e6.js";function C(m){let i;const p=new R({props:{data:"React.memo",id:"reactMemo",isBig:"true"}}),c=new b({props:{data:'<p>React.memo can be used to stop unnecessory re renders in function component. To say simply this is like <a href="/courses/reactJs/reactComponents/reactPureComponents" target="_blank">PureComponents</a> or <a href="/courses/reactJs/reactComponents/reactComponentLifecycle#shouldComponentUpdate" target="_blank">shouldComponentUpdate</a> in class components.</p>'}}),d=new y({props:{language:"javascript",uid:"ae5536b1-6b4f-11ea-8d59-1328692dfd92",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.Component {\n    state = {\n        list: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                const newList = state.list;\n                newList.push(\"item\" + this.count++);\n                return ({\n                        list: newList\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {\n                    this.state.list.map(item => <ListItem key={item} name={item}/>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nconst ListItem = (props)=> {\n    console.log(\"Rendering: \" + props.name);\n    return (\n        <p>{props.name}</p>\n    )\n}\n\nReactDOM.render(<List/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:""}}),l=new b({props:{data:'<p>Here for every minute we are adding a new item to the list. If we run this code output looks fine, but if we open the console we can see the<span style="color: rgb(0, 0, 0);"> </span><strong>Rendering log is printed for all the items in the list for every push in the list</strong><span style="color: rgb(0, 0, 0);">. </span>That means all the items of the list are re-rendered. But this is not what we are expecting, we need to render only the newly added item not the entire list.</p><p><br></p><p>Here <strong>React.memo</strong> can optimise this behaviour.</p><p><br></p><p>In the below example at line no 35 we are wrapping the<span style="color: rgb(0, 0, 0);"> </span><em>ListItem</em> component with <strong>React.memo</strong>.</p>'}}),g=new y({props:{language:"javascript",uid:"8754f151-6b53-11ea-8d59-1328692dfd92",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.Component {\n    state = {\n        list: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                const newList = state.list;\n                newList.push(\"item\" + this.count++);\n                return ({\n                        list: newList\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {\n                    this.state.list.map(item => <ListItem key={item} name={item}/>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nconst ListItem = React.memo((props)=> {\n    console.log(\"Rendering: \" + props.name);\n    return (\n        <p>{props.name}</p>\n    )\n})\n\nReactDOM.render(<List/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:"35"}}),$=new b({props:{data:"<p>Now if we see the console we can notice that <strong>Rendering log </strong>for only newly added item is printed. That means only newly added item is created and existing List items are untouched.</p><p><br></p><p>For every push in the list <em>List</em> Component is re-rendered so <strong>shouldComponentUpdate</strong> for all the <em>ListItem</em> Components are called, as <em>ListItem</em> is a react meno and <strong>props.name </strong>is not changed existing List items are untouched.</p>"}}),f=new L({props:{data:"<ul><li><strong>React.memo </strong>can boost performance.</li><li>If <strong>React.memo</strong> skips a re-render all it's children components are also not re-rendered.</li></ul>"}});return{c(){e(p.$$.fragment),e(c.$$.fragment),e(d.$$.fragment),e(l.$$.fragment),e(g.$$.fragment),e($.$$.fragment),e(f.$$.fragment)},l(e){t(p.$$.fragment,e),t(c.$$.fragment,e),t(d.$$.fragment,e),t(l.$$.fragment,e),t(g.$$.fragment,e),t($.$$.fragment,e),t(f.$$.fragment,e)},m(e,t){n(p,e,t),n(c,e,t),n(d,e,t),n(l,e,t),n(g,e,t),n($,e,t),n(f,e,t),i=!0},p:s,i(e){i||(a(p.$$.fragment,e),a(c.$$.fragment,e),a(d.$$.fragment,e),a(l.$$.fragment,e),a(g.$$.fragment,e),a($.$$.fragment,e),a(f.$$.fragment,e),i=!0)},o(e){r(p.$$.fragment,e),r(c.$$.fragment,e),r(d.$$.fragment,e),r(l.$$.fragment,e),r(g.$$.fragment,e),r($.$$.fragment,e),r(f.$$.fragment,e),i=!1},d(e){o(p,e),o(c,e),o(d,e),o(l,e),o(g,e),o($,e),o(f,e)}}}function x(s){let h,u,w;const R=new I({props:{$$slots:{default:[C]},$$scope:{ctx:s}}});return{c(){h=m("meta"),u=i(),e(R.$$.fragment),this.h()},l(e){const n=p('[data-svelte="svelte-1inpb83"]',document.head);h=c(n,"META",{name:!0,content:!0}),n.forEach(d),u=l(e),t(R.$$.fragment,e),this.h()},h(){document.title="React.memo",g(h,"name","description"),g(h,"content","React.memo")},m(e,t){$(document.head,h),f(e,u,t),n(R,e,t),w=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),R.$set(n)},i(e){w||(a(R.$$.fragment,e),w=!0)},o(e){r(R.$$.fragment,e),w=!1},d(e){d(h),e&&d(u),o(R,e)}}}export default class extends h{constructor(e){super(),u(this,e,null,x,w,{})}}
