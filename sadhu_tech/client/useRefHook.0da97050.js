import{l as e,m as t,o as n,n as a,t as r,p as s,q as i,e as o,s as f,C as m,c,d as u,b as l,f as p,h as $,i as g,S as d,j as R,k as h}from"./client.f707559f.js";import"./Icon.b3087117.js";import"./Button.46d81a0e.js";import"./Image.a80d16de.js";import"./stores.ec09ff7a.js";import{H as v,a as b,P as w,N as y,C as I}from"./index.b8f1b6e6.js";function j(o){let f;const m=new v({props:{data:"useRef",id:"useRef",isBig:"true"}}),c=new b({props:{language:"javascript",uid:"cd08e921-7307-11ea-9c38-adea875d5f90",data:"/**\n * @param takes an initial value for its .current property. It can be of any type.\n * @return same object for every re-render.\n */\nconst aRef = useRef(initialValue);",pic:"",ratio:"4",highlight:""}}),u=new w({props:{data:"<p><em>useRef</em> holds a mutable value in it's <em>.current</em> property. It carries this mutable value for every render. <em>ref.current</em> is a javaScript object that can hold references of DOM element as well as any custom object.</p><p><br></p><p><em>useRef</em> can be treated as instance variable of class component because It holds a mutable value and persists till the life of function component.</p><p><br></p>"}}),l=new v({props:{data:"Accessing DOM elements with useRef",id:"accessingDOMElementsWithUseRef"}}),p=new b({props:{language:"javascript",uid:"da471461-730a-11ea-9c38-adea875d5f90",data:"import React, {useEffect, useRef} from 'react';\nimport ReactDOM from 'react-dom';\nimport './App.css';\n\nconst FocusInput = () => {\n    const inputRef = useRef(null);\n\n    useEffect(() => {\n        inputRef.current.focus()\n    }, []);\n\n    return (\n        <React.Fragment>\n            <input ref={inputRef} placeholder=\"Product Name\"/>\n        </React.Fragment>\n    );\n};\n\nexport default FocusInput;\n\nReactDOM.render(<FocusInput/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:"1,6,9,14"}}),$=new w({props:{data:"<p>In this example we are focussing our input element on the first render.</p><p><br></p><ul><li>At line 1 we are importing <em>useRef</em>.</li><li>At line 6 we are creating inputRef with null as initial value.</li><li>At line 14 <em>ref={inputRef}</em> sets the <em>.current</em> property of inputRef.</li><li>At line 9 we are focussing the input element.</li></ul>"}}),g=new v({props:{data:"Keeping a variable in useRef",id:"keepingAVariableInUseRef"}}),d=new b({props:{language:"javascript",uid:"bfe6d6c1-7317-11ea-9c38-adea875d5f90",data:"import React, {useEffect, useRef, useState} from 'react';\nimport ReactDOM from 'react-dom';\nimport './App.css';\n\nconst Timer = () => {\n    const [count, setCount] = useState(0);\n    const timerRef = useRef(null);\n\n    useEffect(() => {\n        timerRef.current = setInterval(() => {\n            setCount(previousCount => previousCount + 1)\n        }, 1000)\n    }, []);\n\n    return (\n        <React.Fragment>\n            <p>{count}</p>\n            <button onClick={()=> clearInterval(timerRef.current)}>Clear Interval</button>\n        </React.Fragment>\n    );\n};\n\nexport default Timer;\n\nReactDOM.render(<Timer/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:"7, 10-13,18"}}),R=new w({props:{data:"<p>In this example <em>useRef</em> holds <em>timerRef</em> for re-renders.</p><p><br></p><ul><li>At line 7 we are creating timerRef with null as initial value.</li><li>At line 10 we are assigning interval reference to <em>.current</em> property of <em>timerRef</em>. Here at every second <strong>setCount()</strong> is called so the function re-renders, <em>useRef</em> gives same <em>timerRef</em> reference every time.</li><li>At line 18 <em>clearInterval(timerRef.current)</em> the interval is cleared on button click. As <em>timerRef.current</em> is persisted for every render this works.</li></ul><p><br></p>"}}),h=new y({props:{data:'<ul><li>Refs can be used to asses DOM or React nodes and for keeping mutable variables.</li><li>Ref current value can be assigned in <a href="/courses/reactJs/reactHooks/useEffectHook" target="_blank">useEffect</a>, useLayoutEffect and event handlers.</li><li>Changing ref current value doesn\'t give any trigger or doesn\'t cause re-render.</li></ul>'}});return{c(){e(m.$$.fragment),e(c.$$.fragment),e(u.$$.fragment),e(l.$$.fragment),e(p.$$.fragment),e($.$$.fragment),e(g.$$.fragment),e(d.$$.fragment),e(R.$$.fragment),e(h.$$.fragment)},l(e){t(m.$$.fragment,e),t(c.$$.fragment,e),t(u.$$.fragment,e),t(l.$$.fragment,e),t(p.$$.fragment,e),t($.$$.fragment,e),t(g.$$.fragment,e),t(d.$$.fragment,e),t(R.$$.fragment,e),t(h.$$.fragment,e)},m(e,t){n(m,e,t),n(c,e,t),n(u,e,t),n(l,e,t),n(p,e,t),n($,e,t),n(g,e,t),n(d,e,t),n(R,e,t),n(h,e,t),f=!0},p:a,i(e){f||(r(m.$$.fragment,e),r(c.$$.fragment,e),r(u.$$.fragment,e),r(l.$$.fragment,e),r(p.$$.fragment,e),r($.$$.fragment,e),r(g.$$.fragment,e),r(d.$$.fragment,e),r(R.$$.fragment,e),r(h.$$.fragment,e),f=!0)},o(e){s(m.$$.fragment,e),s(c.$$.fragment,e),s(u.$$.fragment,e),s(l.$$.fragment,e),s(p.$$.fragment,e),s($.$$.fragment,e),s(g.$$.fragment,e),s(d.$$.fragment,e),s(R.$$.fragment,e),s(h.$$.fragment,e),f=!1},d(e){i(m,e),i(c,e),i(u,e),i(l,e),i(p,e),i($,e),i(g,e),i(d,e),i(R,e),i(h,e)}}}function A(a){let d,R,h;const v=new I({props:{$$slots:{default:[j]},$$scope:{ctx:a}}});return{c(){d=o("meta"),R=f(),e(v.$$.fragment),this.h()},l(e){const n=m('[data-svelte="svelte-ak2g0n"]',document.head);d=c(n,"META",{name:!0,content:!0}),n.forEach(u),R=l(e),t(v.$$.fragment,e),this.h()},h(){document.title="React useRef",p(d,"name","description"),p(d,"content","React useRef")},m(e,t){$(document.head,d),g(e,R,t),n(v,e,t),h=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),v.$set(n)},i(e){h||(r(v.$$.fragment,e),h=!0)},o(e){s(v.$$.fragment,e),h=!1},d(e){u(d),e&&u(R),i(v,e)}}}export default class extends d{constructor(e){super(),R(this,e,null,A,h,{})}}
