import{l as e,m as t,o as n,n as a,t as s,p as o,q as r,e as i,s as p,C as c,c as m,d as l,b as d,f as g,h as $,i as u,S as f,j as h,k as b}from"./client.9c259cf4.js";import"./Icon.680bd4d0.js";import"./Button.44f5306d.js";import"./Image.c8019b1e.js";import"./stores.2b7dbef2.js";import{H as w,P as y,a as k,N as R,C as L}from"./index.7beba4f9.js";function I(i){let p;const c=new w({props:{data:"React.memo",id:"reactMemo",isBig:"true"}}),m=new y({props:{data:'<p>React.memo can be used to stop unnecessory re renders in function component. To say simply this is like <a href="/courses/reactJs/reactComponents/reactPureComponents" target="_blank">PureComponents</a> or <a href="/courses/reactJs/reactComponents/reactComponentLifecycle#shouldComponentUpdate" target="_blank">shouldComponentUpdate</a> in class components.</p>'}}),l=new k({props:{language:"javascript",uid:"ae5536b1-6b4f-11ea-8d59-1328692dfd92",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.Component {\n    state = {\n        list: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                const newList = state.list;\n                newList.push(\"item\" + this.count++);\n                return ({\n                        list: newList\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {\n                    this.state.list.map(item => <ListItem key={item} name={item}/>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nconst ListItem = (props)=> {\n    console.log(\"Rendering: \" + props.name);\n    return (\n        <p>{props.name}</p>\n    )\n}\n\nReactDOM.render(<List/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:""}}),d=new y({props:{data:'<p>Here for every minute we are adding a new item to the list. If we run this code output looks fine, but if we open the console we can see the<span style="color: rgb(0, 0, 0);"> </span><strong>Rendering log is printed for all the items in the list for every push in the list</strong><span style="color: rgb(0, 0, 0);">. </span>That means all the items of the list are re-rendered. But this is not what we are expecting, we need to render only the newly added item not the entire list.</p><p><br></p><p>Here <strong>React.memo</strong> can optimise this behaviour.</p><p><br></p><p>In the below example at line no 35 we are wrapping the<span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(255, 255, 255); background-color: black;"> ListItem </span> component with <strong>React.memo</strong>.</p>'}}),g=new k({props:{language:"javascript",uid:"8754f151-6b53-11ea-8d59-1328692dfd92",data:"import React from 'react';\nimport './App.css';\nimport ReactDOM from \"react-dom\";\n\nexport class List extends React.Component {\n    state = {\n        list: []\n    };\n    count = 0;\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState((state) => {\n                const newList = state.list;\n                newList.push(\"item\" + this.count++);\n                return ({\n                        list: newList\n                    }\n                );\n            });\n        }, 1000)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                {\n                    this.state.list.map(item => <ListItem key={item} name={item}/>)\n                }\n            </React.Fragment>\n        );\n    }\n}\n\nconst ListItem = React.memo((props)=> {\n    console.log(\"Rendering: \" + props.name);\n    return (\n        <p>{props.name}</p>\n    )\n})\n\nReactDOM.render(<List/>, document.getElementById('root'));",pic:"",ratio:"4",highlight:"35"}}),$=new y({props:{data:'<p>Now if we see the console we can notice that <strong>Rendering log </strong>for only newly added item is printed. That means only newly added item is created and existing List items are untouched.</p><p><br></p><p>For every push in the list <span style="background-color: black;"> </span><span style="background-color: black; color: rgb(255, 255, 255);">List</span><span style="background-color: black;"> </span> Component is re-rendered so <strong>shouldComponentUpdate</strong> for all the <span style="background-color: black;"> </span><span style="background-color: black; color: rgb(255, 255, 255);">ListItem</span><span style="background-color: black;"> </span> Components are called, as <span style="background-color: black;"> </span><span style="background-color: black; color: rgb(255, 255, 255);">ListItem</span><span style="background-color: black;"> </span> is a react meno and <strong>props.name </strong>is not changed existing List items are untouched.</p>'}}),u=new R({props:{data:"<ul><li><strong>React.memo </strong>can boost performance.</li><li>If <strong>React.memo</strong> skips a re-render all it's children components are also not re-rendered.</li></ul>"}});return{c(){e(c.$$.fragment),e(m.$$.fragment),e(l.$$.fragment),e(d.$$.fragment),e(g.$$.fragment),e($.$$.fragment),e(u.$$.fragment)},l(e){t(c.$$.fragment,e),t(m.$$.fragment,e),t(l.$$.fragment,e),t(d.$$.fragment,e),t(g.$$.fragment,e),t($.$$.fragment,e),t(u.$$.fragment,e)},m(e,t){n(c,e,t),n(m,e,t),n(l,e,t),n(d,e,t),n(g,e,t),n($,e,t),n(u,e,t),p=!0},p:a,i(e){p||(s(c.$$.fragment,e),s(m.$$.fragment,e),s(l.$$.fragment,e),s(d.$$.fragment,e),s(g.$$.fragment,e),s($.$$.fragment,e),s(u.$$.fragment,e),p=!0)},o(e){o(c.$$.fragment,e),o(m.$$.fragment,e),o(l.$$.fragment,e),o(d.$$.fragment,e),o(g.$$.fragment,e),o($.$$.fragment,e),o(u.$$.fragment,e),p=!1},d(e){r(c,e),r(m,e),r(l,e),r(d,e),r(g,e),r($,e),r(u,e)}}}function C(a){let f,h,b;const w=new L({props:{$$slots:{default:[I]},$$scope:{ctx:a}}});return{c(){f=i("meta"),h=p(),e(w.$$.fragment),this.h()},l(e){const n=c('[data-svelte="svelte-1inpb83"]',document.head);f=m(n,"META",{name:!0,content:!0}),n.forEach(l),h=d(e),t(w.$$.fragment,e),this.h()},h(){document.title="React.memo",g(f,"name","description"),g(f,"content","React.memo")},m(e,t){$(document.head,f),u(e,h,t),n(w,e,t),b=!0},p(e,[t]){const n={};1&t&&(n.$$scope={dirty:t,ctx:e}),w.$set(n)},i(e){b||(s(w.$$.fragment,e),b=!0)},o(e){o(w.$$.fragment,e),b=!1},d(e){l(f),e&&l(h),r(w,e)}}}export default class extends f{constructor(e){super(),h(this,e,null,C,b,{})}}
